import os
from pathlib import Path
import unittest
import numpy as np
import matplotlib.pyplot as plt

# Kangerlussuaq average temperature:
T_KANGER = np.array([-19.7, -21.0, -17., -8.4, 2.3, 8.4,
10.7, 8.5, 3.1, -6.0, -12.0, -16.9])

def temp_kanger(t):
    '''
    For an array of times in days, return timeseries of temperature for
    Kangerlussuaq, Greenland.
    '''
    t_amp = (T_KANGER - T_KANGER.mean()).max()
    return t_amp*np.sin(np.pi/180 * t - np.pi/2) + T_KANGER.mean()

def default_init(U_arr,xgrid):
    """
    Function to default initialise the U array using
    4*x - 4*(x**2).

    Note that this doesn't have to be the case, and the
    user could define any function they wanted to pass in
    here.

    Parameters
    -----------
    U_arr : np.ndarray
        2D array for the heat equation
    xgrid : np.array
        1D array representing the grid spacing in the x direction

    """
    U_arr[:, 0] = 4*xgrid - 4*xgrid**2

def default_bounds(U_arr,**kwargs):
    """
    Default function for enforcing boundary conditions
    in a simulation.

    In this case, we set the upper and lower boundary
    to 0 in both directions.

    Parameters : U_arr
        U array used in the heat equation
    """
    # set the top boundary conditions to 0
    U_arr[0, :] = 0
    # set the bottom boundary conditions to 0
    U_arr[-1, :] = 0

def kanger_bounds(U_arr,time_arr):
    """
    Helper function to set the boundary
    conditions for Kangerlussuaq, Greenland.

    In this case, the upper boundary conditions are set
    using the timeseries of daily temperatures generated by
    the temp_kanger function, interpolated to whatever the
    unit of time in the solver is.

    The lower boundary conditions are set to be constant at
    5C, which represents geothermal warming.

    Parameters
    ----------
    U_arr : np.ndarray
        2D U array in the heat equation solver
    time_arr : np.array
        array of times in days
    """
    # time is in seconds, 1 day = 86400 seconds so convert time arr to days
    # get daily timeseries and interpolate to dt resolution
    temps = temp_kanger(time_arr/86400)
    # now set upper bounds
    U_arr[0, :] = temps
    # set lower bounds to 5
    U_arr[-1, :] = 5

def heatdiff(xmax, tmax, dx, dt, bconds=default_bounds ,init=default_init, c2=1, debug=0):
    '''
    Function to solve the 1D heat diffusion equation in time.

    This function first checks the stability of the input parameters (if they are not stable, errors).
    It then initialises the simulation using user defined or preset functions for initial and
    boundary conditions, and loops in time for a minimum of 2 years (or until the simulation is complete).

    After 2 years, a covergence check sequence is initiated at the end of each year to see if the
    temperature in the isothermal zone has been constant. If so, the simulation terminates.

    Parameters:
    -----------
    xmax : float
        maximum depth of the ground in the x direction
    tmax : float
        maximum amount of time in seconds
    dx : float
        grid spacing in the x direction
    dt : float
        time step in seconds
    bconds : function
        user defined function to enforce boundary conditions
        in the simulation.
        Defaults to default_bounds(), sets to 0
    init : function
        user defined function to set initial conditions on
        the heat grid.
        Defaults to default_init(), sets to 4x - 4x^2
    c2 : float
        coefficient of heat diffusion
    debug : int
        verbosity of debugging output.
        Defaults to 0/False (No output)

    Returns:
    --------
    xgrid : np.ndarray
        array representing depth
    tgrid : np.ndarray
        array representing time
    U : np.ndarray
        array representing temperature in the simulation

    '''
    # perform initial check for stability
    if dt <= (dx**2)/(2 * (c2**2)):
        raise(ValueError(f'Initial conditions dx : {dx}, dt : {dt}, c2 :{c2} are unstable.'))
    
    # Start by calculating size of array: MxN
    M = int(np.round(xmax / dx + 1))
    N = int(np.round(tmax / dt + 1))

    xgrid, tgrid = np.arange(0, xmax+dx, dx), np.arange(0, tmax+dt, dt)

    if debug:
        print(f'Our grid goes from 0 to {xmax}m and 0 to {tmax}s')
        print(f'Our spatial step is {dx} and time step is {dt}')
        print(f'There are {M} points in space and {N} points in time.')
        print('Here is our spatial grid:')
        print(xgrid)
        print('Here is our time grid:')
        print(tgrid)

    # Initialize our data array:
    print(type(N))
    print(type(M))
    U = np.zeros((M, N))

    # use default initialization function
    # NOTE: the user could define any function they like here or pass in a lambda
    init(U,xgrid)

    # enforce boundary conditions
    bconds(U,time_arr=tgrid)

    # Set our "r" constant.
    r = c2 * dt / dx**2

    # Solve! Forward differnce ahoy.
    # loop in time

    for j,t in zip(range(N-1),tgrid):
        U[1:-1, j+1] = (1-2*r) * U[1:-1, j] + \
            r*(U[2:, j] + U[:-2, j])
        
        # enforce boundary conditions
        bconds(U,time_arr=tgrid)

        # add convergence check for the isothermal region
        # note that time must be > 2 years to start enforcing this
        if (t > (2 * 3.156e7)) and (t % 3.156e7 == 0):
            # more than 2 years have passed
            # compare the temperatures in the isothermal zone
            continue

    # Return grid and result:
    return xgrid, tgrid, U


class TestNlayeratmos(unittest.TestCase):
    """
    Class contains unit tests for the verification step in the 
    lab methodology.

    Adapted from https://www.geeksforgeeks.org/unit-testing-python-unittest/
    """
    def test_2layer_halfepsilon(self):
        """
        Unit test solves for test case given in lab code.
        """
        # Solution to problem 10.3 from fink/matthews as a nested list:
        sol10p3 = [[0.000000, 0.640000, 0.960000, 0.960000, 0.640000, 0.000000],
        [0.000000, 0.480000, 0.800000, 0.800000, 0.480000, 0.000000],
        [0.000000, 0.400000, 0.640000, 0.640000, 0.400000, 0.000000],
        [0.000000, 0.320000, 0.520000, 0.520000, 0.320000, 0.000000],
        [0.000000, 0.260000, 0.420000, 0.420000, 0.260000, 0.000000],
        [0.000000, 0.210000, 0.340000, 0.340000, 0.210000, 0.000000],
        [0.000000, 0.170000, 0.275000, 0.275000, 0.170000, 0.000000],
        [0.000000, 0.137500, 0.222500, 0.222500, 0.137500, 0.000000],
        [0.000000, 0.111250, 0.180000, 0.180000, 0.111250, 0.000000],
        [0.000000, 0.090000, 0.145625, 0.145625, 0.090000, 0.000000],
        [0.000000, 0.072812, 0.117813, 0.117813, 0.072812, 0.000000]]
        # Convert to an array and transpose it to get correct ordering:
        sol10p3 = np.array(sol10p3).transpose()

        # solve the heat equation for the test case
        _,_,solver_result = heatdiff(1,0.2,0.2,0.02)
        # confirm the coefficients and the temperatures are equal to 1 decimal place
        np.testing.assert_allclose(solver_result, sol10p3, rtol=1E10)


def main():
    """
    main function executes all code necessary to reproduce
    the figures in the lab report. Will execute all code in order.
    """
    pass

# run the main function when calling script
if __name__ == "__main__":
    # first run the unit tests to ensure everything works
    # do not exit the script
    print('testing n_layer_atmos solver')
    unittest.main(exit=False)
    # now execute the code for the class if everything works
    print('\nExecuting Lab Experiments')
    print('--------------------------')
    main()
